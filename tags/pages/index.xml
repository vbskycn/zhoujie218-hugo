<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Pages on 周杰个人博客</title><link>/tags/pages/</link><description>Recent content in Pages on 周杰个人博客</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Sun, 13 Jul 2025 00:00:00 +0000</lastBuildDate><atom:link href="/tags/pages/index.xml" rel="self" type="application/rss+xml"/><item><title>新款Worker路由反代全球Cloudflare IP优选！让Cloudflare在国内再也不是减速器！</title><link>/archives/2673.html</link><pubDate>Sun, 13 Jul 2025 00:00:00 +0000</pubDate><guid>/archives/2673.html</guid><description>&lt;h4 id="已优选"&gt;已优选&lt;/h4&gt;
&lt;p&gt;
 &lt;a data-fancybox="gallery" href="https://img-cloud.zhoujie218.top/2025/07/13/6873817265d92.png"&gt;
 &lt;img class="mx-auto" alt="image-20250713175038879" src="https://img-cloud.zhoujie218.top/2025/07/13/6873817265d92.png" /&gt;
 &lt;/a&gt;
 &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;结论：可见，优选过的网站响应速度有很大提升，并且出口IP也变多了。这能让你的网站可用性大大提高，并且加载速度显著变快。&lt;/p&gt;
&lt;p&gt;Cloudflare 优选域名：www.visa.cn&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id="worker路由反代全球并优选新"&gt;Worker路由反代全球并优选（新）&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;本方法的原理为通过Worker反代你的源站，然后将Worker的入口节点进行优选。此方法不是传统的优选，源站接收到的Hosts头仍然是直接指向源站的解析&lt;/p&gt;
&lt;p&gt;以下代码是原Github全站反代代码的二改以实现Worker路由接入优选，可能有多余逻辑或者不完全适配于优选需求&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;创建一个Cloudflare Worker，写入代码&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;// 域名前缀映射配置
const domain_mappings = {
 &amp;#39;live-1vz.pages.dev&amp;#39;: &amp;#39;live&amp;#39;,
//例如：
//&amp;#39;live-1vz.pages.dev&amp;#39;: &amp;#39;live&amp;#39;,
//则你设置Worker路由为live*.都将会反代到live-1vz.pages.dev
};

addEventListener(&amp;#39;fetch&amp;#39;, event =&amp;gt; {
 event.respondWith(handleRequest(event.request));
});

async function handleRequest(request) {
 const url = new URL(request.url);
 const current_host = url.host;

 // 强制使用 HTTPS
 if (url.protocol === &amp;#39;http:&amp;#39;) {
 url.protocol = &amp;#39;https:&amp;#39;;
 return Response.redirect(url.href, 301);
 }

 const host_prefix = getProxyPrefix(current_host);
 if (!host_prefix) {
 return new Response(&amp;#39;Proxy prefix not matched&amp;#39;, { status: 404 });
 }

 // 查找对应目标域名
 let target_host = null;
 for (const [origin_domain, prefix] of Object.entries(domain_mappings)) {
 if (host_prefix === prefix) {
 target_host = origin_domain;
 break;
 }
 }

 if (!target_host) {
 return new Response(&amp;#39;No matching target host for prefix&amp;#39;, { status: 404 });
 }

 // 构造目标 URL
 const new_url = new URL(request.url);
 new_url.protocol = &amp;#39;https:&amp;#39;;
 new_url.host = target_host;

 // 创建新请求
 const new_headers = new Headers(request.headers);
 new_headers.set(&amp;#39;Host&amp;#39;, target_host);
 new_headers.set(&amp;#39;Referer&amp;#39;, new_url.href);

 try {
 const response = await fetch(new_url.href, {
 method: request.method,
 headers: new_headers,
 body: request.method !== &amp;#39;GET&amp;#39; &amp;amp;&amp;amp; request.method !== &amp;#39;HEAD&amp;#39; ? request.body : undefined,
 redirect: &amp;#39;manual&amp;#39;
 });

 // 复制响应头并添加CORS
 const response_headers = new Headers(response.headers);
 response_headers.set(&amp;#39;access-control-allow-origin&amp;#39;, &amp;#39;*&amp;#39;);
 response_headers.set(&amp;#39;access-control-allow-credentials&amp;#39;, &amp;#39;true&amp;#39;);
 response_headers.set(&amp;#39;cache-control&amp;#39;, &amp;#39;public, max-age=600&amp;#39;);
 response_headers.delete(&amp;#39;content-security-policy&amp;#39;);
 response_headers.delete(&amp;#39;content-security-policy-report-only&amp;#39;);

 return new Response(response.body, {
 status: response.status,
 statusText: response.statusText,
 headers: response_headers
 });
 } catch (err) {
 return new Response(`Proxy Error: ${err.message}`, { status: 502 });
 }
}

function getProxyPrefix(hostname) {
 for (const prefix of Object.values(domain_mappings)) {
 if (hostname.startsWith(prefix)) {
 return prefix;
 }
 }
 return null;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建路由&lt;/p&gt;</description></item></channel></rss>